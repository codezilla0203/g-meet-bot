<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Meeting Recording - CXFlow Meeting Bot</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
	<style>
		[data-typography="poppins"] {
			font-family: 'Poppins', sans-serif;
		}
		
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}
		body { 
			font-family: 'Poppins', sans-serif; 
			margin: 0; 
			color: #111; 
			background: #f3f4f6; 
		}
		header { 
			background: #111827; 
			color: #fff; 
			padding: 16px 20px; 
			box-shadow: 0 2px 8px rgba(0,0,0,0.1);
		}
		header h1 { 
			margin: 0; 
			font-size: 20px;
			font-weight: 600;
			display: flex;
			align-items: center;
			gap: 8px;
		}
		.subtitle {
			font-size: 13px;
			color: #9ca3af;
			margin-top: 4px;
		}
		
		/* Mobile responsive fixes */
		@media (max-width: 480px) {
			header {
				padding: 12px 16px;
			}
			header h1 {
				font-size: 18px;
				gap: 6px;
			}
			header h1 img {
				width: 20px !important;
				height: 20px !important;
			}
			.subtitle {
				font-size: 12px;
				margin-top: 2px;
			}
		}
		main { 
			max-width: 1400px; 
			margin: 0 auto; 
			padding: 24px 20px 40px; 
			width: 100%;
			box-sizing: border-box;
			overflow-x: hidden;
		}
		.card { 
			background: #fff; 
			border: 1px solid #e5e7eb; 
			border-radius: 12px; 
			padding: 20px; 
			margin-bottom: 20px; 
			box-shadow: 0 1px 3px rgba(0,0,0,0.05); 
		}
		.card-title {
			font-size: 16px;
			font-weight: 600;
			margin-bottom: 16px;
			color: #111827;
		}
		.status-badge {
			padding: 4px 12px;
			border-radius: 12px;
			font-size: 12px;
			font-weight: 500;
			text-transform: capitalize;
		}
		.status-completed {
			background: #d1fae5;
			color: #065f46;
		}
		.status-recording {
			background: #fee2e2;
			color: #991b1b;
		}
		.status-pending {
			background: #fef3c7;
			color: #92400e;
		}
		.btn-small {
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 13px;
			font-weight: 500;
			font-family: 'Poppins', sans-serif;
			cursor: pointer;
			transition: all 0.2s;
			text-decoration: none;
			display: inline-flex;
			align-items: center;
			gap: 6px;
		}
		.bot-detail {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 24px;
			width: 100%;
			max-width: 100%;
			box-sizing: border-box;
			overflow: hidden;
		}
		.bot-detail-left {
			display: flex;
			flex-direction: column;
			gap: 20px;
		}
		.summary-section {
			background: #f9fafb;
			padding: 20px;
			border-radius: 12px;
			border: 1px solid #e5e7eb;
			min-height: 400px;
			max-height: 54vh;
			display: flex;
			flex-direction: column;
			overflow: hidden;
		}
		.keywords-section {
			padding-bottom: 20px;
			margin-bottom: 20px;
			border-bottom: 1px solid #e5e7eb;
		}
		.keywords-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 12px;
		}
		.keywords-title {
			font-size: 14px;
			font-weight: 500;
			color: #111827;
		}
		.keywords-tags {
			display: flex;
			flex-wrap: wrap;
			gap: 8px;
		}
		.keyword-tag {
			display: inline-block;
			padding: 6px 12px;
			border-radius: 16px;
			font-size: 13px;
			font-weight: 500;
			color: #111827;
			white-space: nowrap;
		}
		.no-keywords {
			font-size: 13px;
			color: #9ca3af;
			font-style: italic;
		}
		.summary-header {
			flex-shrink: 0;
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 12px;
		}
		.summary-title {
			font-size: 15px;
			font-weight: 600;
			color: #111827;
		}
		.copy-summary-btn {
			background: transparent;
			border: none;
			cursor: pointer;
			padding: 6px;
			border-radius: 4px;
			color: #6b7280;
			font-family: 'Poppins', sans-serif;
			display: flex;
			align-items: center;
			transition: all 0.2s;
		}
		.copy-summary-btn:hover {
			background: #f3f4f6;
			color: #111827;
		}
		.summary-content {
			flex: 1;
			overflow-y: auto;
			overflow-x: hidden;
			font-size: 14px;
			line-height: 1.7;
			color: #374151;
			white-space: pre-wrap;
			padding-bottom: 20px;
			/* Hide scrollbar but keep scrolling */
			scrollbar-width: none; /* Firefox */
			-ms-overflow-style: none; /* IE and Edge */
		}
		.summary-content::-webkit-scrollbar {
			display: none; /* Chrome, Safari, Opera */
		}
		.transcript-section {
			background: #fff;
			border: 1px solid #e5e7eb;
			border-radius: 12px;
			padding: 0;
			min-height: 400px;
			max-height: 100vh;
			display: flex;
			flex-direction: column;
			overflow: hidden;
			position: relative;
		}
		.transcript-header-sticky {
			position: sticky;
			top: 0;
			flex-shrink: 0;
			background: #fff;
			z-index: 100;
			padding: 16px 20px;
			margin-bottom: 0;
			width: 100%;
			box-sizing: border-box;
		}
		.transcript-tabs {
			display: flex;
			gap: 0;
			margin-bottom: 12px;
		}
		.transcript-tab {
			padding: 8px 16px;
			background: transparent;
			border: none;
			border-bottom: 2px solid transparent;
			cursor: pointer;
			font-size: 14px;
			font-weight: 500;
			font-family: 'Poppins', sans-serif;
			color: #6b7280;
			transition: all 0.2s;
			margin-bottom: -2px;
		}
		.transcript-tab:hover {
			color: #111827;
		}
		.transcript-tab.active {
			color: #8b5cf6;
			border-bottom-color: #8b5cf6;
		}
		.transcript-search {
			position: relative;
		}
		.transcript-search svg {
			position: absolute;
			left: 12px;
			top: 50%;
			transform: translateY(-50%);
			color: #9ca3af;
			pointer-events: none;
			z-index: 1;
		}
		.transcript-search-input {
			width: 100%;
			padding: 10px 0px 10px 43px !important;
			padding-left: 36px;
			border: 1px solid #e5e7eb;
			border-radius: 6px;
			font-size: 13px;
			font-family: 'Poppins', sans-serif;
			background: #f9fafb;
			color: #111827;
			box-sizing: border-box;
		}
		.transcript-search-input:focus {
			outline: none;
			border-color: #8b5cf6;
			background: #fff;
		}
		.transcript-scrollable {
			flex: 1;
			overflow-y: auto;
			overflow-x: hidden;
			padding: 20px;
			padding-top: 16px;
			padding-bottom: 20px;
			min-height: 0;
			/* Hide scrollbar but keep scrolling */
			scrollbar-width: none; /* Firefox */
			-ms-overflow-style: none; /* IE and Edge */
		}
		.transcript-scrollable::-webkit-scrollbar {
			display: none; /* Chrome, Safari, Opera */
		}
		.transcript-item {
			padding: 16px 0;
			border-bottom: 1px solid #f3f4f6;
			cursor: pointer;
			transition: background-color 0.2s;
		}

		.transcript-item:hover {
			background-color: #f9fafb;
		}

		.transcript-text:hover {
			color: #3b82f6 !important;
			background-color: #eff6ff;
			padding: 2px 4px;
			border-radius: 4px;
			cursor: pointer;
			transition: all 0.2s ease;
		}

		/* Active/playing transcript styling - only text is red */
		.transcript-item.active .transcript-text {
			color: #ef4444 !important;
			font-weight: 600;
			background-color: #fef2f2;
			padding: 2px 4px;
			border-radius: 4px;
			transition: all 0.3s ease;
		}

		.transcript-item:last-child {
			border-bottom: none;
		}
		.transcript-header {
			display: flex;
			align-items: center;
			gap: 12px;
			margin-bottom: 8px;
		}
		.speaker-name {
			font-weight: 600;
			color: #111827;
			font-size: 14px;
		}
		.time-link {
			font-size: 12px;
			padding: 4px 10px;
			border-radius: 4px;
			background: #f3f4f6;
			color: #6b7280;
			border: 1px solid #e5e7eb;
			cursor: pointer;
			transition: all 0.2s;
		}
		.time-link:hover {
			background: #e5e7eb;
			color: #111827;
		}
		.transcript-text {
			color: #374151;
			font-size: 14px;
			line-height: 1.6;
			cursor: pointer;
		}
		.speaker-info {
			display: flex;
			align-items: center;
			gap: 8px;
			margin-bottom: 6px;
		}
		.speaker-circle {
			width: 32px;
			height: 32px;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 13px;
			font-weight: 600;
			color: #fff;
			flex-shrink: 0;
		}
		.talktime-table {
			width: 100%;
		}
		.talktime-header-row {
			display: grid;
			grid-template-columns: 1fr auto auto;
			gap: 16px;
			padding: 12px 0;
			border-bottom: 1px solid #e5e7eb;
			margin-bottom: 8px;
		}
		.talktime-header-cell {
			font-size: 12px;
			font-weight: 600;
			color: #6b7280;
			text-transform: uppercase;
			letter-spacing: 0.5px;
		}
		.speakers-header {
			text-align: left;
		}
		.wpm-header {
			text-align: center;
			width: 80px;
		}
		.talktime-header {
			text-align: right;
			width: 100px;
		}
		.talktime-row {
			display: grid;
			grid-template-columns: 1fr auto auto;
			gap: 16px;
			padding: 12px 0;
			border-bottom: 1px solid #f3f4f6;
			align-items: center;
		}
		.talktime-row:last-child {
			border-bottom: none;
		}
		.talktime-cell {
			display: flex;
			align-items: center;
		}
		.speaker-cell {
			gap: 12px;
		}
		.speaker-icon {
			width: 32px;
			height: 32px;
			border-radius: 6px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 13px;
			font-weight: 600;
			color: #fff;
			flex-shrink: 0;
		}
		.wpm-cell {
			justify-content: center;
			gap: 6px;
			width: 80px;
		}
		.wpm-dot {
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background: #8b5cf6;
		}
		.wpm-value {
			font-size: 14px;
			font-weight: 500;
			color: #111827;
		}
		.talktime-cell-chart {
			justify-content: flex-end;
			gap: 8px;
			width: 100px;
		}
		.donut-chart {
			width: 40px;
			height: 40px;
		}
		.donut-background {
			fill: none;
			stroke: #e5e7eb;
			stroke-width: 4;
		}
		.donut-progress {
			fill: none;
			stroke: #8b5cf6;
			stroke-width: 4;
			transition: stroke-dashoffset 0.3s;
		}
		.talktime-percentage {
			font-size: 14px;
			font-weight: 600;
			color: #111827;
		}
		.empty-state {
			text-align: center;
			padding: 60px 20px;
			color: #9ca3af;
		}
		.empty-state-icon {
			font-size: 48px;
			margin-bottom: 16px;
		}
		.empty-state-text {
			font-size: 16px;
			color: #6b7280;
		}
		.loading {
			text-align: center;
			padding: 60px 20px;
		}
		.spinner {
			width: 50px;
			height: 50px;
			border: 4px solid #e5e7eb;
			border-top-color: #2563eb;
			border-radius: 50%;
			animation: spin 0.8s linear infinite;
			margin: 0 auto 20px;
		}
		@keyframes spin {
			to { transform: rotate(360deg); }
		}
		footer {
			text-align: center;
			padding: 20px;
			color: #6b7280;
			font-size: 13px;
			border-top: 1px solid #e5e7eb;
			margin-top: 40px;
		}
		@media (max-width: 968px) {
			.bot-detail {
				display: flex;
				flex-direction: column;
				width: 100%;
				max-width: 100%;
				box-sizing: border-box;
			}
		}
		
		@media (max-width: 768px) {
			body {
				overflow-x: hidden;
			}
			header {
				padding: 12px 16px;
			}
			header h1 {
				font-size: 18px;
			}
			main {
				padding: 16px 12px 24px;
				width: 100%;
				max-width: 100vw;
				box-sizing: border-box;
			}
			.summary-section {
				padding: 16px;
				max-height: 45vh;
			}
			.transcript-section {
				height: calc(100vh - 200px);
				min-height: 500px;
			}
			.transcript-header-sticky {
				padding: 16px 16px 12px 16px;
			}
			.transcript-scrollable {
				padding: 16px;
				padding-top: 12px;
			}
			.bot-detail {
				display: flex !important;
				flex-direction: column !important;
				gap: 16px;
				width: 100%;
				max-width: 100%;
				box-sizing: border-box;
			}
			.bot-detail-left {
				width: 100%;
				max-width: 100%;
				box-sizing: border-box;
			}
			/* Bot detail content mobile fixes */
			.card {
				padding: 16px;
				margin-bottom: 16px;
				width: 100%;
				max-width: 100%;
				box-sizing: border-box;
			}
			/* Video player mobile fixes */
			#professionalVideoPlayer {
				width: 100% !important;
				max-width: 100% !important;
				box-sizing: border-box;
			}
			/* Meeting info header mobile fixes */
			div[style*="flex-wrap: wrap"] {
				flex-direction: column !important;
				align-items: stretch !important;
				gap: 12px !important;
			}
			div[style*="gap: 8px"][style*="flex-wrap: wrap"] {
				flex-direction: column !important;
				gap: 8px !important;
			}
			div[style*="gap: 8px"][style*="flex-wrap: wrap"] a {
				width: 100% !important;
				justify-content: center !important;
				text-align: center !important;
			}
		}
	</style>
</head>
<body data-typography="poppins">
	<header>
		<h1><img src="https://www.cxflow.io/app/images/logo.png" alt="CXFlow Logo" style="width: 24px; height: 24px; vertical-align: middle; margin-right: 8px;"> CXFlow Meeting Bot</h1>
		<div class="subtitle">Shared Meeting Recording</div>
	</header>
	
	<main>
		<div id="loadingState" class="loading">
			<div class="spinner"></div>
			<p>Loading meeting...</p>
		</div>

		<div id="errorState" class="empty-state" style="display: none;">
			<div class="empty-state-icon">‚ö†Ô∏è</div>
			<div class="empty-state-text" id="errorMessage">Meeting not found</div>
		</div>

		<div id="contentState" style="display: none;">
			<div style="margin-bottom: 16px; padding: 12px; background: #f9fafb; border-radius: 8px; border: 1px solid #e5e7eb;">
				<div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px;">
					<div>
						<strong style="font-size: 16px;"><img src="https://www.cxflow.io/app/images/logo.png" alt="CXFlow Logo" style="width: 16px; height: 16px; vertical-align: middle; margin-right: 4px;"> <span id="meetingTitle">Meeting Recording</span></strong>
						<div style="font-size: 13px; color: #6b7280; margin-top: 4px;" id="meetingMeta"></div>
					</div>
					<div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
						<a href="" id="downloadVideoBtn" class="btn-small" style="background: white; color: #2563eb; border: 1px solid #2563eb; padding: 8px 16px; border-radius: 6px; text-decoration: none; font-weight: 500; display: inline-flex; align-items: center; gap: 6px;" download>
							<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
								<path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z"/>
							</svg>
							Download Video
						</a>
						<a href="" id="exportPdfBtn" class="btn-small" style="background: #dc2626; color: white; border: none; padding: 8px 16px; border-radius: 6px; text-decoration: none; font-weight: 500; display: inline-flex; align-items: center; gap: 6px;" download>
							<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
								<path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
							</svg>
							Export PDF
						</a>
						<button id="shareEmailBtn" class="btn-small" style="background: #059669; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 500; display: inline-flex; align-items: center; gap: 6px;">
							<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
								<path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
							</svg>
							Share via Email
						</button>
					</div>
				</div>
			</div>
			<div class="bot-detail">
				<div class="bot-detail-left">
					<div id="professionalVideoPlayer"></div>
					<div class="summary-section">
						<div class="keywords-section">
							<div class="keywords-header">
								<div class="keywords-title">Keywords:</div>
							</div>
							<div class="keywords-tags" id="keywordsTags"></div>
						</div>
						<div class="summary-header">
							<div class="summary-title">AI Meeting Summary</div>
							<button class="copy-summary-btn" id="copySummaryBtn" title="Copy summary">
								<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
									<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
									<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
								</svg>
							</button>
						</div>
						<div class="summary-content" id="summaryContent">No summary available</div>
					</div>
				</div>
				<div class="transcript-section">
					<div class="transcript-header-sticky">
						<div class="transcript-tabs">
							<button class="transcript-tab active" data-tab="transcript" id="transcriptTab">Transcript <span id="transcriptCount"></span></button>
							<button class="transcript-tab" data-tab="talktime" id="talktimeTab">Speaker Talktime</button>
						</div>
						<div class="transcript-search" id="transcriptSearchContainer">
							<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #9ca3af;">
								<circle cx="11" cy="11" r="8"></circle>
								<path d="m21 21-4.35-4.35"></path>
							</svg>
							<input type="text" id="transcriptSearch" placeholder="Find or Replace" class="transcript-search-input">
						</div>
					</div>
					<div id="transcriptContainer" class="transcript-scrollable"></div>
					<div id="talktimeContainer" class="transcript-scrollable" style="display: none;"></div>
				</div>
			</div>
		</div>
	</main>

	<footer>
		<p>Powered by <strong>CXFlow Meeting Bot</strong></p>
		<p style="margin-top: 8px; font-size: 12px;">This is a shared meeting recording. For more information, contact the meeting organizer.</p>
	</footer>

	<script src="./video-player.js"></script>
	<script>
		const loadingState = document.getElementById('loadingState');
		const errorState = document.getElementById('errorState');
		const contentState = document.getElementById('contentState');
		const errorMessage = document.getElementById('errorMessage');

		// Get share token from URL
		const urlParams = new URLSearchParams(window.location.search);
		const shareToken = urlParams.get('token') || urlParams.get('id');

		if (!shareToken) {
			showError('No share token provided');
		} else {
			loadMeeting(shareToken);
		}

		async function loadMeeting(token) {
			try {
				// Fetch meeting data
				const response = await fetch(`/api/share/${encodeURIComponent(token)}`);
				
				if (!response.ok) {
					if (response.status === 404) {
						throw new Error('Meeting not found or link expired');
					} else if (response.status === 403) {
						throw new Error('Access denied');
					} else {
						throw new Error('Failed to load meeting');
					}
				}

				const data = await response.json();
				
				if (!data.success) {
					throw new Error(data.error || 'Failed to load meeting');
				}

				await renderMeeting(data);
			} catch (error) {
				console.error('Error loading meeting:', error);
				showError(error.message);
			}
		}

		// Global video player reference (same as bot detail page)
		let videoPlayer = null;

		function buildUtterances(captions, meetingStartTime = null) {
			console.log(`üîß buildUtterances called with:`, {
				captionsType: Array.isArray(captions) ? 'array' : typeof captions,
				captionsLength: captions ? captions.length : 0,
				meetingStartTime: meetingStartTime,
				firstCaption: captions && captions.length > 0 ? captions[0] : null
			});
			
			if (!Array.isArray(captions) || captions.length === 0) {
				console.warn(`‚ö†Ô∏è No valid captions array provided to buildUtterances`);
				return [];
			}

			const sorted = [...captions].sort((a, b) => (a.timestampMs || 0) - (b.timestampMs || 0));
			console.log(`üìä Sorted ${sorted.length} captions for processing`);
			const utterances = [];
			let current = null;
			
			// Use meeting start time from bot data (from extension's meetingStartTimeStamp)
			let meetingStartTimeMs = null;
			if (meetingStartTime) {
				try {
					meetingStartTimeMs = new Date(meetingStartTime).getTime();
				} catch (e) {
					console.warn('Failed to parse meeting start time:', meetingStartTime);
				}
			}
			
			// Fallback: find the earliest timestampMs
			if (!meetingStartTimeMs) {
				for (const cap of sorted) {
					if (cap.timestampMs) {
						if (!meetingStartTimeMs || cap.timestampMs < meetingStartTimeMs) {
							meetingStartTimeMs = cap.timestampMs;
						}
					}
				}
			}

			for (const cap of sorted) {
				const speaker = (cap.personName || cap.speaker || 'Unknown Speaker').trim();
				const text = String(cap.personTranscript || cap.text || '').trim();
				
				// Use timestampMs - meetingStartTimeMs to get the actual speaker start time
				let startTimeSeconds = 0;
				if (cap.timestampMs && meetingStartTimeMs) {
					// Calculate seconds from meeting start using timestampMs
					startTimeSeconds = (cap.timestampMs - meetingStartTimeMs) / 1000;
				} else {
					// Fallback to offsetSeconds if no timestampMs
					startTimeSeconds = Number.isFinite(cap.offsetSeconds) ? cap.offsetSeconds : 0;
				}

				if (!text) continue;

				if (!current) {
					current = { speaker, startOffset: startTimeSeconds, text, lastText: text, lastOffset: startTimeSeconds };
					continue;
				}

				const sameSpeaker = speaker === current.speaker;
				const gapSeconds = startTimeSeconds - current.lastOffset;

				if (sameSpeaker && gapSeconds <= 5) {
					if (text.length >= current.lastText.length && text.startsWith(current.lastText.slice(0, 10))) {
						current.text = text;
						current.lastText = text;
						current.lastOffset = startTimeSeconds;
					} else {
						current.text = `${current.text} ${text}`;
						current.lastText = current.text;
						current.lastOffset = startTimeSeconds;
					}
				} else {
					utterances.push({
						speaker: current.speaker,
						startOffset: current.startOffset,
						text: current.text,
					});
					current = { speaker, startOffset: startTimeSeconds, text, lastText: text, lastOffset: startTimeSeconds };
				}
			}

			if (current) {
				utterances.push({
					speaker: current.speaker,
					startOffset: current.startOffset,
					text: current.text,
				});
			}

			console.log(`üéØ buildUtterances returning ${utterances.length} utterances:`, 
				utterances.slice(0, 3).map(u => ({ speaker: u.speaker, startOffset: u.startOffset, textLength: u.text.length })));
			return utterances;
		}

	async function renderMeeting(data) {
		const { bot, apiTranscript, summary } = data;
		
		console.log(`üìä Rendering meeting data:`, {
			botId: bot.id,
			transcriptLength: apiTranscript ? apiTranscript.length : 0,
			summaryLength: summary ? summary.length : 0,
			botMetrics: bot.metrics ? 'present' : 'missing'
		});
		
		// Use transcript from API response (already loaded from RUNTIME_ROOT)
		let transcript = apiTranscript || [];
		console.log(`üìù Initial transcript data: ${transcript.length} items`);

		// Try legacy API only if needed
		if (!transcript || transcript.length === 0) {
			try {
				const tRes = await fetch(`/v1/transcripts/${encodeURIComponent(bot.id)}`);
				if (tRes.ok) {
					const tData = await tRes.json();
					transcript = Array.isArray(tData.captions) ? tData.captions : [];
				}
			} catch (e) {
				console.error('Failed to fetch transcript from legacy API:', e);
			}
		}
		
		// Declare highlighting variables at the top for proper scope
		let lastHighlightedItem = null; // Track the last highlighted item
		let isUserSeeking = false; // Track if user is manually seeking
			
		// Reset user seeking flag after a delay
		function resetUserSeekingFlag() {
			setTimeout(() => {
				isUserSeeking = false;
			}, 1000);
		}
			
		// Force reset user seeking flag (for immediate reset)
		function forceResetUserSeekingFlag() {
			const wasUserSeeking = isUserSeeking;
			
			isUserSeeking = false;
			
			// Force a highlighting update when we reset the flag
			if (wasUserSeeking && videoPlayer && videoPlayer.video) {
				const currentTime = videoPlayer.video.currentTime;
				
				// Reset lastHighlightedItem to force a fresh highlight
				lastHighlightedItem = null;
				
				try {
					highlightCurrentTranscript(currentTime);
				} catch (error) {
					console.error('Error in highlightCurrentTranscript:', error);
				}
			}
		}
			
		// Use meeting start time from metrics if available, otherwise fall back to createdAt
		const meetingStartTime = bot.metrics?.duration?.startTime || bot.createdAt;
		console.log(`‚è∞ Meeting start time: ${meetingStartTime}`);
		console.log(`üìã Building utterances from ${transcript.length} transcript items...`);
		
		const utterances = buildUtterances(transcript, meetingStartTime);
		console.log(`‚úÖ Built ${utterances.length} utterances from transcript`);

			// Format dates
			const createdDate = formatDate(bot.createdAt);
			const duration = bot.duration || 'N/A';

			// Set meeting title and metadata
			document.getElementById('meetingTitle').textContent = bot.title || 'Meeting Recording';
			const meta = document.getElementById('meetingMeta');
			meta.innerHTML = `
				<span>üìÖ Created: ${createdDate}</span> ‚Ä¢ 
				<span>‚è±Ô∏è Duration: ${duration}</span> ‚Ä¢ 
				${transcript.length > 0 ? `<span>üí¨ ${transcript.length} utterances</span>` : ''}
			`;

			// Prioritize S3 URL, then videoUrl, then local endpoint (same as main.js)
			let videoUrl;
			if (bot.s3VideoUrl) {
				videoUrl = bot.s3VideoUrl;
				console.log(`üé• Using S3 video URL: ${videoUrl}`);
			} else if (bot.videoUrl && bot.videoUrl.includes('s3.amazonaws.com')) {
				videoUrl = bot.videoUrl;
				console.log(`üé• Using S3 video URL from videoUrl: ${videoUrl}`);
			} else if (bot.videoUrl) {
				videoUrl = bot.videoUrl;
				console.log(`üé• Using custom video URL: ${videoUrl}`);
			} else {
				videoUrl = `/v1/recordings/${encodeURIComponent(bot.id)}`;
				console.log(`üé• Using local video endpoint: ${videoUrl}`);
			}
			try {
				// Get duration from metrics if available
				let videoDuration = 0;
				if (bot.metrics && bot.metrics.duration && bot.metrics.duration.totalSeconds) {
					videoDuration = bot.metrics.duration.totalSeconds;
					console.log(`‚è±Ô∏è Video duration from metrics: ${videoDuration} seconds`);
				} else {
					console.log(`‚ö†Ô∏è No video duration available in metrics`);
				}
				
				console.log(`üé¨ Initializing video player with URL: ${videoUrl}`);
				console.log(`üìä Video player config: duration=${videoDuration}, utterances=${utterances.length}`);
				
				// Initialize video player with same options as bot detail page
				// Throttle transcript highlighting for better performance
				let lastHighlight = 0;
				const HIGHLIGHT_INTERVAL = 0.1; // seconds - more responsive highlighting
				
				
				videoPlayer = new ProfessionalVideoPlayer('professionalVideoPlayer', videoUrl, {
				transcript: utterances,
				duration: videoDuration, // Pass duration from metrics
					onTimeUpdate: (currentTime) => {
						
					// Auto-reset user seeking flag after sufficient time has passed
					if (isUserSeeking && videoPlayer) {
						const timeSinceLastSeek = Date.now() - (window.lastSeekTime || 0);
						
						// Reset after 2 seconds regardless of play state, or immediately if playing for 2+ seconds
						const shouldReset = timeSinceLastSeek > 2000 || (videoPlayer.isPlaying && timeSinceLastSeek > 1500);
						
						if (shouldReset) {
							forceResetUserSeekingFlag();
						} else if (timeSinceLastSeek > 1000) {
						}
					}
					
					// Additional safety: reset if user seeking has been true for too long
					if (isUserSeeking && (Date.now() - (window.lastSeekTime || 0)) > 3000) {
						forceResetUserSeekingFlag();
					}
						
						// Sync transcript highlighting with video playback (throttled)
						// Use absolute difference so it still runs even after seeking backwards.
						if (Math.abs(currentTime - lastHighlight) > HIGHLIGHT_INTERVAL) {
							lastHighlight = currentTime;
							highlightCurrentTranscript(currentTime);
						}
					}
				});
				
			// Make videoPlayer globally accessible for debugging
			window.videoPlayer = videoPlayer;
			
			// Make debugging functions globally accessible
			window.resetAutoSync = forceResetUserSeekingFlag;
			window.checkSyncStatus = () => {
				const timeSince = Date.now() - (window.lastSeekTime || 0);
				const isPlaying = videoPlayer && videoPlayer.isPlaying;
				if (isUserSeeking && timeSince > 2000 && isPlaying) {
					forceResetUserSeekingFlag();
				}
			};
				
			} catch (error) {
				console.error('‚ùå Error initializing video player:', error);
				console.error('üîç Video URL:', videoUrl);
				console.error('üîç Bot data:', bot);
				console.error('üîç Error stack:', error.stack);
				
				// Provide more specific error message
				let errorMsg = 'Video player failed to load';
				if (error.message.includes('network') || error.message.includes('fetch')) {
					errorMsg = 'Failed to load video - network error';
				} else if (error.message.includes('codec') || error.message.includes('format')) {
					errorMsg = 'Video format not supported';
				} else if (videoUrl.includes('s3.amazonaws.com')) {
					errorMsg = 'Failed to load video from S3 storage';
				}
				
				document.getElementById('professionalVideoPlayer').innerHTML = 
					`<div class="empty-state">
						<p style="color: #dc2626; font-weight: 600;">${errorMsg}</p>
						<p style="font-size: 14px; color: #6b7280; margin-top: 8px;">
							Video URL: ${videoUrl.length > 50 ? videoUrl.substring(0, 50) + '...' : videoUrl}
						</p>
						<button onclick="location.reload()" style="margin-top: 12px; padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">
							Retry
						</button>
					</div>`;
			}

			// Set summary
			let formattedSummary = summary || 'No summary available';
			if (formattedSummary !== 'No summary available') {
				formattedSummary = formattedSummary
					.replace(/^# (.+)$/gm, '<h3 style="margin: 16px 0 8px 0; font-size: 16px; font-weight: 600;">$1</h3>')
					.replace(/^## (.+)$/gm, '<h4 style="margin: 12px 0 6px 0; font-size: 14px; font-weight: 600;">$1</h4>')
					.replace(/^### (.+)$/gm, '<h5 style="margin: 8px 0 4px 0; font-size: 13px; font-weight: 600;">$1</h5>')
					.replace(/^‚Ä¢ (.+)$/gm, '<li style="margin-left: 20px;">$1</li>')
					.replace(/\n\n/g, '<br><br>')
					.replace(/\n/g, '<br>');
			}
			document.getElementById('summaryContent').innerHTML = formattedSummary;

			// Render keywords
			const keywordsTags = document.getElementById('keywordsTags');
			if (keywordsTags) {
				keywordsTags.innerHTML = renderKeywords(bot.keywords || bot.metrics?.keywords?.byKeyword || {});
			}

		// Audio player removed - video player now controls transcript synchronization

		const transcriptContainer = document.getElementById('transcriptContainer');

		if (!utterances || utterances.length === 0) {
			console.log(`‚ö†Ô∏è No utterances available - transcript: ${transcript.length} items, utterances: ${utterances.length}`);
			transcriptContainer.innerHTML = `
				<div class="empty-state">
					<p style="color: #6b7280; margin-bottom: 12px;">üìù No transcript available</p>
					<p style="font-size: 14px; color: #9ca3af;">
						${transcript.length === 0 ? 
							'This meeting recording does not have transcript data. This could happen if captions were not enabled during the meeting.' :
							'Transcript data could not be processed into utterances.'
						}
					</p>
					<p style="font-size: 12px; color: #9ca3af; margin-top: 8px;">
						Video duration: ${bot.duration || 'Unknown'} ‚Ä¢ Meeting ID: ${bot.id.slice(0, 8)}
					</p>
				</div>
			`;
			
			// Clear transcript count
			const transcriptCountEl = document.getElementById('transcriptCount');
			if (transcriptCountEl) {
				transcriptCountEl.textContent = '(0)';
			}
			transcriptContainer.innerHTML = '<div class="empty-state"><p>No transcript available</p></div>';
			// // Clear count if no transcript
			// const transcriptCountEl = document.getElementById('transcriptCount');
			// if (transcriptCountEl) {
			// 	transcriptCountEl.textContent = '';
			// }
			return;
		}
		
		// Update transcript count (same as share page)
		const transcriptCountEl = document.getElementById('transcriptCount');
		if (transcriptCountEl) {
			transcriptCountEl.textContent = `(${utterances.length})`;
		}

		// Get unique speakers for color assignment (consistent order)
		const uniqueSpeakers = [...new Set(utterances.map(u => u.speaker).filter(Boolean))];
		const speakerColorMap = {};
		uniqueSpeakers.forEach((speaker) => {
			speakerColorMap[speaker] = getSpeakerColor(speaker, uniqueSpeakers);
		});

		// Calculate speaking time for each utterance (same as main.js)
		utterances.forEach((utt, index) => {
			// Find next utterance to determine end time
			const nextUtt = utterances.find((u, i) => i > index && u.startOffset > utt.startOffset);
			const endTime = nextUtt ? nextUtt.startOffset : (utt.startOffset + 3); // Default 3 seconds if last
			utt.speakingTime = Math.max(0, endTime - utt.startOffset);
		});


		// Render transcript items
		for (const utt of utterances) {
			const item = document.createElement('div');
			item.className = 'transcript-item';
			const startTime = utt.startOffset || 0;
			const uttSpeakingTime = utt.speakingTime || 0;
			const endTime = startTime + uttSpeakingTime;
			item.dataset.startTime = startTime;
			item.dataset.endTime = endTime;
			
			// Make entire transcript item clickable for better UX
			item.style.cursor = 'pointer';
			item.addEventListener('click', (e) => {
				// Only trigger if clicking on the item itself (not on nested clickable elements)
				if (e.target === item) {
					if (videoPlayer) {
						const startTime = utt.startOffset || 0;
						isUserSeeking = true; // Mark as user-initiated seek
						window.lastSeekTime = Date.now(); // Track when user last seeked
						
						// Force pause first to ensure seek works
						if (videoPlayer.isPlaying) {
							videoPlayer.video.pause();
						}
						
						// Immediately highlight the clicked item
						if (lastHighlightedItem) {
							lastHighlightedItem.classList.remove('active');
						}
						item.classList.add('active');
						lastHighlightedItem = item;
						
						
						// Seek and wait for buffer, then play - ensure sync is perfect
						videoPlayer.seekTo(startTime).then(() => {
							// Verify we're at the right position before playing
							const currentTime = videoPlayer.video.currentTime;
							const timeDiff = Math.abs(currentTime - startTime);
							if (timeDiff < 0.5) {
								// Position is correct, play
								videoPlayer.video.play().catch(err => {
									console.error('Play error:', err);
								});
							} else {
								// Position mismatch, try seeking again
								videoPlayer.video.currentTime = startTime;
								videoPlayer.video.addEventListener('seeked', () => {
									videoPlayer.video.play().catch(err => {
										console.error('Play error:', err);
									});
								}, { once: true });
							}
							resetUserSeekingFlag();
						}).catch(err => {
							console.error('Seek error:', err);
							// Fallback: force seek and play
							videoPlayer.video.pause();
							videoPlayer.video.currentTime = startTime;
							videoPlayer.video.addEventListener('seeked', () => {
								videoPlayer.video.play().catch(e => console.error('Play error:', e));
							}, { once: true });
							resetUserSeekingFlag();
						});
					}
				}
			});

			const speakerInitial = getSpeakerInitial(utt.speaker);
			const speakerColor = speakerColorMap[utt.speaker] || '#6b7280';

			// Create speaker circle
			const speakerCircle = document.createElement('div');
			speakerCircle.className = 'speaker-circle';
			speakerCircle.textContent = speakerInitial;
			speakerCircle.style.backgroundColor = speakerColor;
			speakerCircle.style.color = '#fff';
			speakerCircle.style.width = '32px';
			speakerCircle.style.height = '32px';
			speakerCircle.style.borderRadius = '50%';
			speakerCircle.style.display = 'flex';
			speakerCircle.style.alignItems = 'center';
			speakerCircle.style.justifyContent = 'center';
			speakerCircle.style.fontSize = '13px';
			speakerCircle.style.fontWeight = '600';
			speakerCircle.style.flexShrink = '0';

			// Create speaker info container
			const speakerInfo = document.createElement('div');
			speakerInfo.className = 'speaker-info';
			speakerInfo.style.display = 'flex';
			speakerInfo.style.alignItems = 'center';
			speakerInfo.style.gap = '8px';
			speakerInfo.style.marginBottom = '6px';

			const speakerName = document.createElement('span');
			speakerName.className = 'speaker-name';
			speakerName.textContent = utt.speaker;
			speakerName.style.fontWeight = '500';
			speakerName.style.fontSize = '14px';
			speakerName.style.color = '#111827';

			const timeStamp = document.createElement('span');
			timeStamp.className = 'time-stamp';
			timeStamp.textContent = formatTime(utt.startOffset || 0);
			timeStamp.style.fontSize = '12px';
			timeStamp.style.color = '#6b7280';
			timeStamp.style.cursor = 'pointer';
			timeStamp.addEventListener('click', (e) => {
				e.stopPropagation(); // Prevent item click from firing
				if (videoPlayer) {
					const startTime = utt.startOffset || 0;
					isUserSeeking = true; // Mark as user-initiated seek
					window.lastSeekTime = Date.now(); // Track when user last seeked
					
					// Force pause first to ensure seek works
					if (videoPlayer.isPlaying) {
						videoPlayer.video.pause();
					}
					
					// Immediately highlight the clicked item
					if (lastHighlightedItem) {
						lastHighlightedItem.classList.remove('active');
					}
					timeStamp.closest('.transcript-item').classList.add('active');
					lastHighlightedItem = timeStamp.closest('.transcript-item');
					
					// Seek and wait for buffer, then play - ensure sync is perfect
					videoPlayer.seekTo(startTime).then(() => {
						// Verify we're at the right position before playing
						const currentTime = videoPlayer.video.currentTime;
						const timeDiff = Math.abs(currentTime - startTime);
						if (timeDiff < 0.5) {
							// Position is correct, play
							videoPlayer.video.play().catch(err => {
								console.error('Play error:', err);
							});
						} else {
							// Position mismatch, try seeking again
							videoPlayer.video.currentTime = startTime;
							videoPlayer.video.addEventListener('seeked', () => {
								videoPlayer.video.play().catch(err => {
									console.error('Play error:', err);
								});
							}, { once: true });
						}
						resetUserSeekingFlag();
					}).catch(err => {
						console.error('Seek error:', err);
						// Fallback: force seek and play
						videoPlayer.video.pause();
						videoPlayer.video.currentTime = startTime;
						videoPlayer.video.addEventListener('seeked', () => {
							videoPlayer.video.play().catch(e => console.error('Play error:', e));
						}, { once: true });
						resetUserSeekingFlag();
					});
				}
			});

			speakerInfo.appendChild(speakerCircle);
			speakerInfo.appendChild(speakerName);
			speakerInfo.appendChild(document.createTextNode(' ¬∑ '));
			speakerInfo.appendChild(timeStamp);

			const text = document.createElement('div');
			text.className = 'transcript-text';
			text.textContent = utt.text;
			text.style.fontSize = '14px';
			text.style.lineHeight = '1.6';
			text.style.color = '#374151';
			text.style.marginLeft = '40px';
			text.style.cursor = 'pointer';
			// Make text clickable to seek video
			text.addEventListener('click', (e) => {
				e.stopPropagation(); // Prevent item click from firing
				if (videoPlayer) {
					const startTime = utt.startOffset || 0;
					isUserSeeking = true; // Mark as user-initiated seek
					window.lastSeekTime = Date.now(); // Track when user last seeked
					
					// Force pause first to ensure seek works
					if (videoPlayer.isPlaying) {
						videoPlayer.video.pause();
					}
					
					// Immediately highlight the clicked item
					if (lastHighlightedItem) {
						lastHighlightedItem.classList.remove('active');
					}
					text.closest('.transcript-item').classList.add('active');
					lastHighlightedItem = text.closest('.transcript-item');
					
					// Seek and wait for buffer, then play - ensure sync is perfect
					videoPlayer.seekTo(startTime).then(() => {
						// Verify we're at the right position before playing
						const currentTime = videoPlayer.video.currentTime;
						const timeDiff = Math.abs(currentTime - startTime);
						if (timeDiff < 0.5) {
							// Position is correct, play
							videoPlayer.video.play().catch(err => {
								console.error('Play error:', err);
							});
						} else {
							// Position mismatch, try seeking again
							videoPlayer.video.currentTime = startTime;
							videoPlayer.video.addEventListener('seeked', () => {
								videoPlayer.video.play().catch(err => {
									console.error('Play error:', err);
								});
							}, { once: true });
						}
						resetUserSeekingFlag();
					}).catch(err => {
						console.error('Seek error:', err);
						// Fallback: force seek and play
						videoPlayer.video.pause();
						videoPlayer.video.currentTime = startTime;
						videoPlayer.video.addEventListener('seeked', () => {
							videoPlayer.video.play().catch(e => console.error('Play error:', e));
						}, { once: true });
						resetUserSeekingFlag();
					});
				}
			});

			item.appendChild(speakerInfo);
			item.appendChild(text);
			transcriptContainer.appendChild(item);
		}

		const transcriptItems = Array.from(
			transcriptContainer.querySelectorAll('.transcript-item')
		).map(item => ({
			item,
			start: parseFloat(item.dataset.startTime || 0),
			end: parseFloat(item.dataset.endTime || item.dataset.startTime || 0)
		}));
		  
		let lastHighlightedIndex = -1;

		// Setup copy summary button
		const copySummaryBtn = document.getElementById('copySummaryBtn');
		if (copySummaryBtn) {
			copySummaryBtn.addEventListener('click', () => {
				const summaryText = document.querySelector('.summary-content').textContent;
				navigator.clipboard.writeText(summaryText).then(() => {
					const originalHTML = copySummaryBtn.innerHTML;
					copySummaryBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>';
					setTimeout(() => {
						copySummaryBtn.innerHTML = originalHTML;
					}, 2000);
				}).catch(err => {
				});
			});
		}

		// Setup transcript tabs
		const transcriptTab = document.getElementById('transcriptTab');
		const talktimeTab = document.getElementById('talktimeTab');
		const transcriptSearchContainer = document.getElementById('transcriptSearchContainer');
		const talktimeContainer = document.getElementById('talktimeContainer');
			
			if (transcriptTab && talktimeTab) {
				transcriptTab.addEventListener('click', () => {
					transcriptTab.classList.add('active');
					talktimeTab.classList.remove('active');
					transcriptContainer.style.display = '';
					talktimeContainer.style.display = 'none';
					if (transcriptSearchContainer) transcriptSearchContainer.style.display = '';
					
					// Reset highlighting when switching to transcript tab
					if (typeof lastHighlightedItem !== 'undefined' && lastHighlightedItem) {
						lastHighlightedItem.classList.remove('active');
						lastHighlightedItem = null;
					}
					if (typeof isUserSeeking !== 'undefined') {
						isUserSeeking = false;
					}
					
					// Re-trigger highlighting for current video time if video is playing
					if (videoPlayer && videoPlayer.video && !videoPlayer.video.paused) {
						const currentTime = videoPlayer.video.currentTime;
						if (typeof highlightCurrentTranscript === 'function') {
							highlightCurrentTranscript(currentTime);
						}
					}
				});
				
				talktimeTab.addEventListener('click', () => {
					talktimeTab.classList.add('active');
					transcriptTab.classList.remove('active');
					transcriptContainer.style.display = 'none';
					talktimeContainer.style.display = '';
					if (transcriptSearchContainer) transcriptSearchContainer.style.display = 'none';
					
					// Render speaker talk time if not already rendered
					if (talktimeContainer && talktimeContainer.children.length === 0) {
						renderSpeakerTalkTime(bot, utterances, talktimeContainer);
					}
				});
			}

			// Setup transcript search
			const transcriptSearch = document.getElementById('transcriptSearch');
			if (transcriptSearch) {
				transcriptSearch.addEventListener('input', (e) => {
					const searchTerm = e.target.value.toLowerCase();
					const items = transcriptContainer.querySelectorAll('.transcript-item');
					items.forEach(item => {
						const text = item.textContent.toLowerCase();
						if (text.includes(searchTerm)) {
							item.style.display = '';
						} else {
							item.style.display = 'none';
						}
					});
				});
			}


			// Setup download button
			const downloadVideoBtn = document.getElementById('downloadVideoBtn');
			if (downloadVideoBtn) {
				// For S3 URLs, use direct link; for local, use the endpoint
				if (videoUrl.includes('s3.amazonaws.com')) {
					downloadVideoBtn.href = videoUrl;
				} else {
					downloadVideoBtn.href = `/v1/recordings/${encodeURIComponent(bot.id)}`;
				}
				downloadVideoBtn.download = `meeting-${bot.id}.webm`;
			}

			// Setup PDF export button
			const exportPdfBtn = document.getElementById('exportPdfBtn');
			if (exportPdfBtn) {
				exportPdfBtn.href = `/v1/bots/${encodeURIComponent(bot.id)}/export/pdf`;
				exportPdfBtn.download = `meeting-transcript-${bot.id}.pdf`;
			}

			// Setup share via email button
			const shareEmailBtn = document.getElementById('shareEmailBtn');
			if (shareEmailBtn) {
				shareEmailBtn.addEventListener('click', async () => {
					const originalHTML = shareEmailBtn.innerHTML;
					shareEmailBtn.disabled = true;
					shareEmailBtn.innerHTML = `
						<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="animation: spin 1s linear infinite;">
							<path d="M21 12a9 9 0 11-6.219-8.56"/>
						</svg>
						Sending...
					`;
					
					// Add spinning animation if not already added
					if (!document.querySelector('#spin-animation')) {
						const style = document.createElement('style');
						style.id = 'spin-animation';
						style.textContent = '@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }';
						document.head.appendChild(style);
					}

					try {
						// For share.html, we need to use the current page URL as the share URL
						const currentUrl = window.location.href;
						
						const response = await fetch('/api/share-via-email', {
							method: 'POST',
							headers: {
								'Content-Type': 'application/json'
								// Note: No auth token needed for public share pages
							},
							body: JSON.stringify({
								botId: bot.id,
								shareUrl: currentUrl,
								isPublicShare: true
							})
						});

						const data = await response.json();

						if (response.ok && data.success) {
							shareEmailBtn.innerHTML = `
								<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
									<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
								</svg>
								Email Sent!
							`;
							shareEmailBtn.style.background = '#10b981';
							
							setTimeout(() => {
								shareEmailBtn.innerHTML = originalHTML;
								shareEmailBtn.style.background = '#059669';
								shareEmailBtn.disabled = false;
							}, 3000);
						} else {
							throw new Error(data.error || 'Failed to send email');
						}
					} catch (error) {
						console.error('Share email error:', error);
						
						// Show user-friendly error message
						if (error.message.includes('Authentication') || error.message.includes('login')) {
							alert('Please sign in to share via email. You can copy the link instead.');
						} else {
							alert('Failed to send email. Please try copying the link instead.');
						}
						
						shareEmailBtn.innerHTML = `
							<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
								<path d="M12 2L2 7v10c0 5.55 3.84 9.95 9 11 5.16-1.05 9-5.45 9-11V7l-10-5z"/>
							</svg>
							Failed
						`;
						shareEmailBtn.style.background = '#dc2626';
						
						setTimeout(() => {
							shareEmailBtn.innerHTML = originalHTML;
							shareEmailBtn.style.background = '#059669';
							shareEmailBtn.disabled = false;
						}, 3000);
					}
				});
			}

		
		// Function to highlight current transcript item based on video time
		function highlightCurrentTranscript(currentTime) {
			const seekAge = Date.now() - (window.lastSeekTime || 0);
			
			// If the user just performed a manual seek, give the UI a short grace period
                        // where we don't auto-move the red highlight. After that, we
                        // automatically resume normal syncing.
			if (isUserSeeking && seekAge < 2000) {
				return;
			}

			// After the grace period, automatically re-enable auto-highlighting
			if (isUserSeeking && seekAge >= 2000) {
				isUserSeeking = false;
			}
			
			// Get fresh list of transcript items each time to avoid stale references
			const items = document.querySelectorAll('.transcript-item');
			if (!items.length) {
				return;
			}
		  
			let currentItem = null;
			let currentIndex = -1;
		  
			// Find the item that contains the current time (within start and end time)
			items.forEach((item, index) => {
				const startTime = parseFloat(item.dataset.startTime || 0);
				const endTime = parseFloat(item.dataset.endTime || startTime);
				
				// Check if current time is within this item's time range
				if (currentTime >= startTime && currentTime < endTime) {
					currentItem = item;
					currentIndex = index;
				}
			});
			
			// If no exact match found, find the closest previous item
			if (!currentItem) {
				let closestItem = null;
				let closestTime = -1;
				let closestIndex = -1;
				
				items.forEach((item, index) => {
					const startTime = parseFloat(item.dataset.startTime || 0);
					if (startTime <= currentTime && startTime > closestTime) {
						closestTime = startTime;
						closestItem = item;
						closestIndex = index;
					}
				});
				
				currentItem = closestItem;
				currentIndex = closestIndex;
			}
		  
			// Update highlighting - be more aggressive about ensuring correct visual state
			if (currentItem) {
				const needsUpdate = currentItem !== lastHighlightedItem || !currentItem.classList.contains('active');
				
				if (needsUpdate) {
					// Remove previous highlight from all items (ensure clean state)
					document.querySelectorAll('.transcript-item').forEach(item => {
						item.classList.remove('active');
						item.style.background = '';
						item.style.borderLeft = '';
					});
			  
					// Add new highlight using CSS class
					currentItem.classList.add('active');
					lastHighlightedItem = currentItem;
					lastHighlightedIndex = currentIndex;
				} else {
					// Even if we don't update, ensure the current item has the active class
					if (!currentItem.classList.contains('active')) {
						currentItem.classList.add('active');
					}
				}
		  
				// Scroll into view smoothly (only if not user seeking to avoid jumpy behavior)
				if (!isUserSeeking) {
					currentItem.scrollIntoView({
						behavior: 'smooth',
						block: 'center',
						inline: 'nearest'
					});
				}
			}
		}

		// Show content
		loadingState.style.display = 'none';
		contentState.style.display = 'block';
	}

		function showError(message) {
			loadingState.style.display = 'none';
			errorMessage.textContent = message;
			errorState.style.display = 'block';
		}

		function formatDate(dateString) {
			if (!dateString) return 'N/A';
			const date = new Date(dateString);
			return date.toLocaleDateString('es-MX', {
				year: 'numeric',
				month: 'short',
				day: 'numeric',
				hour: '2-digit',
				minute: '2-digit'
			});
		}

		function formatTime(seconds) {
			if (!Number.isFinite(seconds) || seconds < 0) seconds = 0;
			const s = Math.floor(seconds % 60);
			const m = Math.floor((seconds / 60) % 60);
			const h = Math.floor(seconds / 3600);
			const pad = (n) => String(n).padStart(2, '0');
			if (h > 0) return `${h}:${pad(m)}:${pad(s)}`;
			return `${pad(m)}:${pad(s)}`;
		}

		// Shared color palette for speakers (consistent across all tabs)
		const SPEAKER_COLORS = [
			'#3b82f6', // blue
			'#10b981', // green
			'#f59e0b', // orange
			'#ef4444', // red
			'#8b5cf6', // purple
			'#ec4899', // pink
			'#06b6d4', // cyan
			'#84cc16', // lime
			'#f97316', // orange-red
			'#6366f1'  // indigo
		];

		function getSpeakerColor(speakerName, allSpeakers) {
			const index = allSpeakers.indexOf(speakerName);
			if (index === -1) return '#6b7280'; // Default grey for unknown speakers
			return SPEAKER_COLORS[index % SPEAKER_COLORS.length];
		}

		function getSpeakerInitial(name) {
			if (!name) return '?';
			const parts = name.trim().split(/\s+/);
			if (parts.length >= 2) {
				return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
			}
			return name[0].toUpperCase();
		}

		function renderKeywords(keywordsData) {
			// Handle both array (OpenAI-generated) and object (metrics-based) formats
			let keywords = [];
			if (Array.isArray(keywordsData)) {
				// OpenAI-generated keywords (array)
				keywords = keywordsData;
			} else if (keywordsData && typeof keywordsData === 'object') {
				// Metrics-based keywords (object with counts)
				keywords = Object.keys(keywordsData).sort((a, b) => keywordsData[b] - keywordsData[a]);
			}
			
			if (!keywords || keywords.length === 0) {
				return '<span class="no-keywords">No keywords found</span>';
			}
			
			const keywordColors = [
				'#a78bfa', // purple
				'#86efac', // light green
				'#fca5a5', // light red/pink
				'#fde047', // pale yellow-green
				'#93c5fd', // light blue
				'#f9a8d4', // light pink
				'#c4b5fd', // light purple
				'#6ee7b7'  // mint green
			];
			
			let html = '';
			keywords.forEach((keyword, index) => {
				const color = keywordColors[index % keywordColors.length];
				html += `<span class="keyword-tag" style="background-color: ${color};">${keyword}</span>`;
			});
			return html;
		}

		function renderSpeakerTalkTime(bot, utterances, container) {
			const talkTime = bot.metrics?.talkTime?.byParticipant || {};
			
			if (!talkTime || Object.keys(talkTime).length === 0) {
				container.innerHTML = '<div class="empty-state"><p>No speaker talk time data available</p></div>';
				return;
			}
			
			// Calculate word count per speaker from utterances
			const speakerWordCounts = {};
			if (utterances && utterances.length > 0) {
				utterances.forEach(utt => {
					if (utt.speaker && utt.text) {
						const wordCount = utt.text.trim().split(/\s+/).filter(w => w.length > 0).length;
						speakerWordCounts[utt.speaker] = (speakerWordCounts[utt.speaker] || 0) + wordCount;
					}
				});
			}
			
			// Sort speakers by total time (descending)
			const speakers = Object.entries(talkTime).sort((a, b) => b[1].totalMs - a[1].totalMs);
			
			// Get all unique speakers in consistent order (same as transcript) for color mapping
			const allSpeakers = utterances && utterances.length > 0 
				? [...new Set(utterances.map(u => u.speaker).filter(Boolean))]
				: Object.keys(talkTime);
			
			let html = `
				<div class="talktime-table">
					<div class="talktime-header-row">
						<div class="talktime-header-cell speakers-header">SPEAKERS</div>
						<div class="talktime-header-cell wpm-header">WPM</div>
						<div class="talktime-header-cell talktime-header">TALKTIME</div>
					</div>
			`;
			
			speakers.forEach(([speaker, data]) => {
				const percentage = data.percentage || 0;
				const totalMinutes = data.totalMinutes || (data.totalSeconds / 60);
				const wordCount = speakerWordCounts[speaker] || 0;
				const wpm = totalMinutes > 0 ? Math.round(wordCount / totalMinutes) : 0;
				
				const speakerInitial = getSpeakerInitial(speaker);
				const speakerColor = getSpeakerColor(speaker, allSpeakers);
				
				// Create donut chart SVG
				const radius = 16;
				const circumference = 2 * Math.PI * radius;
				const offset = circumference - (percentage / 100) * circumference;
				
				html += `
					<div class="talktime-row">
						<div class="talktime-cell speaker-cell">
							<div class="speaker-icon" style="background-color: ${speakerColor};">
								${speakerInitial}
							</div>
							<span class="speaker-name">${speaker}</span>
						</div>
						<div class="talktime-cell wpm-cell">
							<span class="wpm-dot"></span>
							<span class="wpm-value">${wpm}</span>
						</div>
						<div class="talktime-cell talktime-cell-chart">
							<svg class="donut-chart" width="40" height="40">
								<circle class="donut-background" cx="20" cy="20" r="${radius}" fill="none" stroke="#e5e7eb" stroke-width="4"/>
								<circle class="donut-progress" cx="20" cy="20" r="${radius}" fill="none" stroke="#8b5cf6" stroke-width="4" 
									stroke-dasharray="${circumference}" 
									stroke-dashoffset="${offset}"
									transform="rotate(-90 20 20)"/>
							</svg>
							<span class="talktime-percentage">${percentage.toFixed(0)}%</span>
						</div>
					</div>
				`;
			});
			
			html += '</div>';
			container.innerHTML = html;
		}
	</script>
</body>
</html>

